You are an expert frontend + Flask/Jinja2 engineer. Improve the UX of Parlanchina by addressing TWO specific issues, without breaking the existing behavior:

1. Mermaid diagrams flicker / show syntax errors while streaming.
2. The input box only sends when clicking the “play / send” button.

Do NOT change:
- The current streaming mechanism for normal text.
- The current Markdown + Mermaid rendering pipeline logic (no refactor, just wrap/extend).
- The overall layout or styling more than strictly necessary.

====================================================
1. Mermaid streaming UX: add a “rendering overlay”
====================================================

Current problem:
- When the model streams a Mermaid diagram in a fenced code block (```mermaid …```), the Mermaid renderer is invoked repeatedly while the text is incomplete.
- This produces visible syntax errors / partial renders that flicker the UI.
- The underlying rendering still works correctly once the full diagram text is received, so we do NOT want to change how/when rendering actually happens at the logic level.

Goal:
- When a Mermaid diagram is being rendered or is likely incomplete, visually COVER the area where the diagram appears with an **opaque rounded “rendering” overlay**.
- The overlay hides flicker and error messages, and suggests that something is being rendered.
- Once the final diagram is fully rendered (or the rendering attempt ends), the overlay disappears.

Design constraints:
- Do NOT stop or modify the streaming text itself.
- Do NOT suppress Mermaid errors at JS level; just make them invisible behind the overlay.
- Normal Markdown-only messages must behave exactly as they do now (no overlay at all).

Behavioral specification:

1. **Detection**
   - For any assistant message that contains at least one ` ```mermaid ` fenced code block:
     - Mark that message as having a “Mermaid render phase”.
   - You may choose one of two scopes for the overlay (pick ONE and implement it correctly):
     - (A) The entire **assistant message bubble** for that response.
     - (B) Only the **Mermaid rendering region** inside that message.
   - If scope (B) is complicated to detect, choose (A) and cover the whole message bubble.

2. **Overlay visuals**
   - The overlay must be:
     - Opaque (or semi-opaque) box with rounded corners.
     - Positioned above the message/mermaid area (z-index) with no layout shift.
     - Visually subtle (e.g. slightly darker/lighter surface than background).
   - It must include a **subtle visual cue** that suggests “rendering in progress,” such as:
     - A small looping shimmer animation,
     - A gentle pulsing dot,
     - Or a minimal spinner icon.
   - The animation must be low-distraction, not a big loader.

3. **Lifecycle**
   - The overlay becomes visible when:
     - An assistant message with a ` ```mermaid ` block starts streaming OR
     - Mermaid rendering for that message is initiated.
   - The overlay is removed when BOTH of these are true:
     - The assistant message has finished streaming (no more chunks).
     - The Mermaid renderer has completed a render pass (success or final failure).
   - If Mermaid fails with a final syntax error, the overlay still disappears and the error / partial output is shown, as today.
   - The mechanism should be reusable later for other long-running rendering tasks, so avoid hardcoding “Mermaid-only” everywhere:
     - Keep the overlay behavior generic (e.g., a message-level “isRenderingHeavyContent” state that Mermaid toggles).

4. **Implementation notes (no code, just contract)**
   - Introduce a per-message UI state flag:
     - e.g. `isRenderingMermaid: boolean`.
   - The rendering overlay:
     - Is controlled entirely via this state flag in the template/JS.
   - Do not modify the underlying Mermaid integration beyond:
     - Setting `isRenderingMermaid` true before/when rendering starts,
     - Setting it false once the final render attempt is done.

====================================================
2. Input box: support Ctrl+Enter to send
====================================================

Current behavior:
- The user can send a message by clicking a “send / play” button.
- Pressing Enter most likely inserts a newline or is already wired; assume current behavior is acceptable.

New required behavior:
- **Ctrl+Enter** must send the current message, exactly as if the user clicked the send button.
- The mouse-based send (clicking the button) must continue to work as before.
- Plain Enter should keep its current behavior:
  - If currently Enter inserts a newline, keep it that way.
  - If it already sends the message, do NOT change that behavior (just ensure Ctrl+Enter is an additional shortcut).

Implementation constraints:
- Add a key handler to the main chat input area (textarea) to:
  - Detect `Ctrl+Enter` (or `Cmd+Enter` on macOS if you want to be robust) and trigger the same submission path used by the send button.
- Do NOT change any backend endpoints or streaming logic for this.
- Do NOT introduce new UI elements; just enhance keyboard interaction.

====================================================
3. Quality and invariants
====================================================

- Normal text-only responses:
  - Must stream and render exactly as before.
  - No overlay, no behavioral changes.

- Mermaid responses:
  - Still stream as text; Mermaid still renders as currently implemented.
  - The only difference is the **temporary visual overlay** masking flicker/errors until render completion.

- Input:
  - Send button unchanged.
  - New keyboard shortcut (Ctrl+Enter) provides a smoother experience but does not remove or alter existing behaviors.

Implement the necessary state, template, and JavaScript changes to satisfy the above contracts without refactoring or breaking the existing core mechanics.
        
