# Parlanchina – MCP Toolbox Panel Behaviour

You are an AI code-generation assistant working on **Parlanchina**, a Python + Flask local chat UI with MCP support.

The MCP integration is already implemented as follows:

- `mcp.json` is read and MCP servers are started correctly. **Do not change this.**
- The app discovers all tools exposed by the MCP servers.
- The UI has a **tool panel** with `id="tool-panel"` that lists tools grouped by server, each with a checkbox.
- When tools are enabled, their definitions are passed to the LLM as the `tools` list so the model can invoke them automatically via tool-calling.
- There is already a mechanism on the backend that accepts a list of enabled tools and uses it when calling the LLM.

Your task is to **extend** this behaviour with a proper “Toolbox” toggle and OK/Cancel semantics, all driven by the `tool-panel`.

---

## High-level requirements

1. **Tool panel toggle**
   - The element with `id="tool-panel"`:
     - Must be **hidden by default** when the chat page loads.
   - Above the chat input box, add a **small button** labeled `Toolbox` (or an icon + label).
     - When this button is clicked:
       - The `tool-panel` should become visible.
       - The current *applied* selection of tools should be loaded into the UI (see “State model” below).

2. **Panel controls (OK / Cancel / Close)**
   - Inside `tool-panel`, add:
     - An **OK** button.
     - A **Cancel** or **Close** button (can be a regular button or an “X” icon).
   - Behaviour:
     - **OK**:
       - Commits the currently checked/unchecked tools as the new active selection.
       - Sends the selection to the backend so it is stored for this session.
       - Closes the `tool-panel`.
     - **Cancel / Close**:
       - Discards any changes made since the panel was opened.
       - Restores the checkboxes to the last committed (applied) selection.
       - Closes the `tool-panel`.

3. **Checkbox behaviour**
   - Toggling a checkbox **must not** immediately affect the active tool selection used by the LLM.
   - Checkboxes only edit a **draft** selection inside the panel.
   - Only pressing **OK** updates the **applied** selection on the server.
   - Pressing **Cancel/Close** reverts the draft back to the applied selection.

4. **Persistence over the session**
   - For the lifetime of a chat session:
     - The last **OK-confirmed** selection must be stored server-side.
     - Every time the user:
       - Sends a chat message, or
       - Re-opens the `tool-panel`,
       the **applied** selection is used.
   - If the user closes and re-opens the `tool-panel`, the checkboxes must reflect the **applied** selection, not any uncommitted changes from a previous open.

5. **Guarantee correct tools for the LLM**
   - The **applied** selection is the only source of truth for which tools are passed to the LLM.
   - For every chat request:
     - The backend must use the applied selection for that session to build the list of tools in the LLM call.
     - No other transient state should override it.

---

## State model

Introduce two levels of state for the tools, per chat session:

1. **Applied selection** (server-side, persisted for the session)
   - The list of tool IDs currently active for the session.
   - Updated **only** when the user presses **OK** in the `tool-panel`.
   - Used in:
     - Chat requests to the LLM (tools list).
     - Initialisation of the checkboxes when opening `tool-panel`.

2. **Draft selection** (client-side, only while the panel is open)
   - Represents the temporary changes from checkbox clicks.
   - Updated immediately on each checkbox toggle.
   - When:
     - **OK** is clicked → draft selection is sent to the server and becomes the new applied selection.
     - **Cancel/Close** is clicked → draft selection is discarded, and checkboxes are reset to match the applied selection next time the panel is opened.

---

## Backend changes

1. **Session-scoped storage for applied tools**
   - Ensure there is a mechanism (e.g. Flask session or server-side store keyed by `session_id`) that stores:
     - `applied_enabled_tools: List[str]`  
       e.g. `["drivew.connect_db", "other.server.tool"]`
   - This must already exist in some form; if not, implement it minimally.

2. **Endpoint to get current applied tools**
   - Implement or adapt an endpoint, for example:
     - `GET /mcp/tools` → returns all tools with a flag indicating whether each is currently applied.
   - Response example:
     ```json
     [
       {
         "server": "drivew",
         "name": "connect_db",
         "id": "drivew.connect_db",
         "description": "...",
         "applied": true
       },
       {
         "server": "drivew",
         "name": "some_other_tool",
         "id": "drivew.some_other_tool",
         "description": "...",
         "applied": false
       }
     ]
     ```
   - This endpoint should read from the MCP manager for the tool list, and from the session store for `applied_enabled_tools`.

3. **Endpoint to commit a new selection**
   - Implement a `POST` endpoint to receive and persist the new applied selection when the user clicks **OK**, for example:
     - `POST /mcp/tools/selection`
   - Request body:
     ```json
     {
       "enabled_tools": ["drivew.connect_db", "other.server.tool"]
     }
     ```
   - Behaviour:
     - Validate that each tool ID corresponds to a known MCP tool.
     - Save the list as the session’s `applied_enabled_tools`.
     - Return the effective applied list in the response.

4. **Use applied selection in chat requests**
   - In the chat handler that calls the LLM:
     - Do **not** rely on any client-provided `enabled_tools`.
     - Instead, read `applied_enabled_tools` for the current session.
     - Build the LLM `tools` list from that selection via the existing MCP manager.
   - This guarantees that:
     - Only the last OK-confirmed selection affects the LLM.
     - The behaviour is consistent even if the frontend reloads.

---

## Frontend changes

The frontend uses the existing template and JavaScript environment (Flask/HTML/JS/HTMX/etc.). Respect the current stack and structure.

1. **Hide `tool-panel` by default**
   - In the template, ensure the element with `id="tool-panel"`:
     - Has CSS or an attribute that hides it initially (e.g. `style="display:none"` or a `hidden` class).
   - Do **not** remove the element; it will be toggled visibility.

2. **Add “Toolbox” button above chat input**
   - In the chat template, above the message input area:
     - Add a small button with label `Toolbox` (or similar).
   - On click:
     - Fetch or ensure the latest applied tools list is available.
     - Populate the checkboxes in `tool-panel` so they reflect the **applied** selection.
     - Show `tool-panel` (e.g. by removing `hidden` or `display:none`).

3. **Implement draft selection logic**
   - In JavaScript:
     - Maintain a data structure for the **draft** selection, e.g. a `Set` of tool IDs.
     - When `tool-panel` is opened:
       - Initialise the draft selection from the applied selection received from the backend (e.g. via `/mcp/tools`).
       - Set checkbox states accordingly.
     - When a checkbox changes:
       - Update the draft selection locally (add/remove the tool ID).
       - Do **not** send anything to the server yet.

4. **OK button behaviour**
   - Attach a click handler to the OK button in `tool-panel`:
     - Send the current draft selection to the backend via `POST /mcp/tools/selection`.
     - On success:
       - Update the **applied** selection stored client-side (if you keep a local copy).
       - Hide `tool-panel`.
     - Handle errors minimally (e.g. console error and keep the panel open).

5. **Cancel / Close button behaviour**
   - Attach a click handler to the Cancel/Close button:
     - Do **not** send anything to the server.
     - Reset the draft selection to match the applied selection the next time the panel is opened.
     - Hide `tool-panel`.

6. **Re-opening the panel**
   - When the user clicks the Toolbox button again:
     - Fetch or use the current **applied** selection.
     - Reinitialise the checkboxes to match it.
     - Show `tool-panel`.

---

## Invariants to maintain

- `tool-panel` is **hidden by default** and only shown when the Toolbox button is clicked.
- The only way to change which tools are active for the LLM is:
  - Open `tool-panel`.
  - Adjust checkboxes.
  - Click **OK**.
- Checkbox toggles alone do **not** affect the LLM.
- **Cancel/Close** discards uncommitted changes.
- For the duration of the chat session:
  - The latest OK-confirmed selection is:
    - What the user sees when re-opening `tool-panel`.
    - What the backend uses to build the LLM `tools` list.

Inspect the current Parlanchina code (templates, JS, Flask routes, MCP manager modules) and implement all of the changes above, making minimal but clean modifications consistent with the existing style.

